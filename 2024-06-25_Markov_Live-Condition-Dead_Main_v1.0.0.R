"
This code was auto-generated by Amua (https://github.com/zward/Amua)
Code generated: Tue Jun 25 08:16:28 CDT 2024
Model name: 2024-06-24_Markov_Live-Condition-Die_v2.1.1
Model type: Markov Model
Simulation type: Cohort
Created by: kun-wookim
Created: Fri Jun 14 15:25:37 CDT 2024
Version created: 0.3.1
Modified by: kun-wookim
Modified: Mon Jun 24 21:32:29 CDT 2024
Version modified: 0.3.1
"

#Mac
setwd("/Users/kun-wookim/Library/CloudStorage/OneDrive-VUMC/Research_discrete-event-simulation/r")

# Load packages -----------------------------------------------------------
load.lib<-c("flexsurv", "msm", "dplyr",
            "ggplot2", "reshape2")
install.lib<-load.lib[!load.lib %in% installed.packages()]
for(lib in install.lib) install.packages(lib,dependencies=TRUE)
sapply(load.lib,require,character=TRUE)



### Define functions
source("functions.R")

### Define parameters
p_Die_background <- 1.0  # Expression: 1
shape_gompertz <- 0.101  # Expression: 0.101
rate_gompertz <- 0.001  # Expression: 0.001
r_condition_annual <- 0.010536051565782628  # Expression: -log(1-r_a_pct)/r_a_dur
r_a_pct <- 0.1  # Expression: 0.1
r_a_dur <- 10.0  # Expression: 10
p_condition_annual <- 0.010480741793785553  # Expression: 1-exp(-r_condition_annual)

### Define variables
p_Die_bg <- 0.001
r_Die_bg <- 0.0010005003335835344

cohortSize <- 1000

# Initialize discount rates
discountRates <- rep(1, 2)
startDiscountCycle <- 0
halfCycle <- FALSE

########## Markov Chain: Live-Die ##########
print("Running Markov Chain: Live-Die ")
numStates <- 3
colNames <- c("Cycle", "Live", "Condition", "Die", "Cycle_Cost", "Cum_Cost", "Cycle_Dis_Cost", "Cum_Dis_Cost", "Cycle_QALE", "Cum_QALE", "Cycle_Dis_QALE", "Cum_Dis_QALE")
trace <- data.frame(matrix(nrow=0, ncol=12))
names(trace) <- colNames
# Initialize prevalence
curPrev <- c()
curPrev[1] <- cohortSize * 1  # Live
curPrev[2] <- cohortSize * 0  # Condition
curPrev[3] <- cohortSize * 0  # Die
newPrev <- curPrev  # copy inital prev
# Initialize variables
p_Die_bg <- rate_gompertz*exp(shape_gompertz*t)exp(-rate_gompertz/shape_gompertz*(exp(shape_gompertz*t)1))
r_Die_bg <- -log(1-p_Die_bg)

# Run chain
# Initialize outcomes
Live_minusDie_Cost <- 0; Live_minusDie_Dis_Cost <- 0
Live_minusDie_QALE <- 0; Live_minusDie_Dis_QALE <- 0
t <- 0  # initialize cycle
terminate <- FALSE
while (terminate == FALSE) {
  # Update progress
  if (t %% 10 == 0){
    cat(t, sep="")
  } else {
    cat(".", sep="")
  }

  # Cycle outcomes
  cycleCost <- 0; cycleCost_dis <- 0
  cycleQALE <- 0; cycleQALE_dis <- 0

  # Update prevalence
  curPrev <- newPrev
  # Simulate state transitions

  # Live
  # Update rewards
  cycleCost <- cycleCost+curPrev[1] * 0
  cycleQALE <- cycleQALE+curPrev[1] * 1
  # Calculate child probs
  sumProb <- 0
  childProbs <- c()
  childProbs[2] <- p_Die_bg; sumProb <- sumProb + childProbs[2]  # Prob Background Death
  childProbs[1] <- 1.0 - sumProb  # Complementary prob
  prev_Survive <- curPrev[1] * childProbs[1]
  prev_BackgroundDeath <- curPrev[1] * childProbs[2]
  # Survive
  # Calculate child probs
  sumProb <- 0
  childProbs <- c()
  childProbs[2] <- p_condition_annual; sumProb <- sumProb + childProbs[2]  # Prob Condition
  childProbs[1] <- 1.0 - sumProb  # Complementary prob
  prev_Live1 <- prev_Survive * childProbs[1]
  prev_Condition1 <- prev_Survive * childProbs[2]
  # Live
  # Transition to Live
  newPrev[1] <- newPrev[1] - prev_Live1
  newPrev[1] <- newPrev[1] + prev_Live1
  # Condition
  # Transition to Condition
  newPrev[1] <- newPrev[1] - prev_Condition1
  newPrev[2] <- newPrev[2] + prev_Condition1
  # Background Death
  # Transition to Die
  newPrev[1] <- newPrev[1] - prev_BackgroundDeath
  newPrev[3] <- newPrev[3] + prev_BackgroundDeath

  # Condition
  # Update rewards
  cycleCost <- cycleCost+curPrev[2] * 0
  cycleQALE <- cycleQALE+curPrev[2] * 1
  # Calculate child probs
  sumProb <- 0
  childProbs <- c()
  childProbs[2] <- p_Die_bg; sumProb <- sumProb + childProbs[2]  # Prob Background Death
  childProbs[1] <- 1.0 - sumProb  # Complementary prob
  prev_Condition2 <- curPrev[2] * childProbs[1]
  prev_BackgroundDeath1 <- curPrev[2] * childProbs[2]
  # Condition
  # Transition to Condition
  newPrev[2] <- newPrev[2] - prev_Condition2
  newPrev[2] <- newPrev[2] + prev_Condition2
  # Background Death
  # Transition to Die
  newPrev[2] <- newPrev[2] - prev_BackgroundDeath1
  newPrev[3] <- newPrev[3] + prev_BackgroundDeath1

  # Die
  # Update rewards
  cycleCost <- cycleCost+curPrev[3] * 0
  cycleQALE <- cycleQALE+curPrev[3] * 0
  # Calculate child probs
  sumProb <- 0
  childProbs <- c()
  childProbs[1] <- 1; sumProb <- sumProb + childProbs[1]  # Prob Dead
  prev_Dead <- curPrev[3] * childProbs[1]
  # Dead
  # Transition to Die
  newPrev[3] <- newPrev[3] - prev_Dead
  newPrev[3] <- newPrev[3] + prev_Dead

  # Update outcomes
  discount <- ifelse(t >= startDiscountCycle, 1 / ((1 + discountRates[1]) ^ (t - startDiscountCycle + 1)), 1)
  cycleCost_dis <- cycleCost * discount
  if (t == 0 & halfCycle) {  # half-cycle correction
    cycleCost <- 0.5 * cycleCost; cycleCost_dis <- 0.5 * cycleCost_dis
  }
  Live_minusDie_Cost <- Live_minusDie_Cost + cycleCost
  Live_minusDie_Dis_Cost <- Live_minusDie_Dis_Cost + cycleCost_dis
  discount <- ifelse(t >= startDiscountCycle, 1 / ((1 + discountRates[2]) ^ (t - startDiscountCycle + 1)), 1)
  cycleQALE_dis <- cycleQALE * discount
  if (t == 0 & halfCycle) {  # half-cycle correction
    cycleQALE <- 0.5 * cycleQALE; cycleQALE_dis <- 0.5 * cycleQALE_dis
  }
  Live_minusDie_QALE <- Live_minusDie_QALE + cycleQALE
  Live_minusDie_Dis_QALE <- Live_minusDie_Dis_QALE + cycleQALE_dis

  # Update trace
  row <- c(t, curPrev, cycleCost, Live_minusDie_Cost, cycleCost_dis, Live_minusDie_Dis_Cost, cycleQALE, Live_minusDie_QALE, cycleQALE_dis, Live_minusDie_Dis_QALE)
  row <- data.frame(matrix(row, nrow=1))
  names(row) <- colNames
  trace <- rbind(trace, row)

  # Check termination condition
  terminate <- (t==1000)
  if (terminate & halfCycle){  # half cycle-correction, update last trace row
    lastRow <- nrow(trace)
    Live_minusDie_Cost <- Live_minusDie_Cost - cycleCost * 0.5
    trace[lastRow, 5] <- trace[lastRow, 5] * 0.5  # Cost
    trace[lastRow, 6] <- trace[lastRow - 1, 6] + trace[lastRow, 5]  # cum Cost
    Live_minusDie_Dis_Cost <- Live_minusDie_Dis_Cost - cycleCost_dis * 0.5
    trace[lastRow, 7] <- trace[lastRow, 7] * 0.5  # Cost discounted
    trace[lastRow, 8] <- trace[lastRow - 1, 8] + trace[lastRow, 7]  # cum Cost discounted
    Live_minusDie_QALE <- Live_minusDie_QALE - cycleQALE * 0.5
    trace[lastRow, 9] <- trace[lastRow, 9] * 0.5  # QALE
    trace[lastRow, 10] <- trace[lastRow - 1, 10] + trace[lastRow, 9]  # cum QALE
    Live_minusDie_Dis_QALE <- Live_minusDie_Dis_QALE - cycleQALE_dis * 0.5
    trace[lastRow, 11] <- trace[lastRow, 11] * 0.5  # QALE discounted
    trace[lastRow, 12] <- trace[lastRow - 1, 12] + trace[lastRow, 11]  # cum QALE discounted
  }

  t <- t + 1  # next cycle

}  # end cycle while loop
setwd("/Users/kun-wookim/OneDrive - VUMC/Research_discrete-event-simulation/r/2024-06-25_Live-Condition-Dead/2024-06-24_Markov_Live-Condition-Die_v2.1.1_Export/")
write.csv(trace, "Live-Die_Trace.csv")  # write trace
cat("done!")

# Report totals
print(paste("Cost:", Live_minusDie_Cost))
print(paste("Cost (Discounted):", Live_minusDie_Dis_Cost))
print(paste("QALE:", Live_minusDie_QALE))
print(paste("QALE (Discounted):", Live_minusDie_Dis_QALE))
print("")

